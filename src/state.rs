// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use wasmlib::host::*;

use crate::*;
use crate::keys::*;
use crate::structs::*;
use crate::typedefs::*;

pub struct MapHashToImmutableCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableCompositions {
    pub fn get_compositions(&self, key: &ScHash) -> ImmutableCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        ImmutableCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToImmutableFracCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableFracCompositions {
    pub fn get_frac_compositions(&self, key: &ScHash) -> ImmutableFracCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        ImmutableFracCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToImmutableFraction {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableFraction {
    pub fn get_fraction(&self, key: &ScHash) -> ImmutableFraction {
        ImmutableFraction { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

pub struct MapHashToImmutableProductPass {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableProductPass {
    pub fn get_product_pass(&self, key: &ScHash) -> ImmutableProductPass {
        ImmutableProductPass { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

pub struct MapHashToImmutableRecyCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableRecyCompositions {
    pub fn get_recy_compositions(&self, key: &ScHash) -> ImmutableRecyCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        ImmutableRecyCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToImmutableRecyclate {
	pub(crate) obj_id: i32,
}

impl MapHashToImmutableRecyclate {
    pub fn get_recyclate(&self, key: &ScHash) -> ImmutableRecyclate {
        ImmutableRecyclate { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

#[derive(Clone, Copy)]
pub struct Immutabletest3State {
    pub(crate) id: i32,
}

impl Immutabletest3State {
    pub fn compositions(&self) -> MapHashToImmutableCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_COMPOSITIONS), TYPE_MAP);
		MapHashToImmutableCompositions { obj_id: map_id }
	}

    pub fn frac_compositions(&self) -> MapHashToImmutableFracCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_FRAC_COMPOSITIONS), TYPE_MAP);
		MapHashToImmutableFracCompositions { obj_id: map_id }
	}

    pub fn fractions(&self) -> MapHashToImmutableFraction {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_FRACTIONS), TYPE_MAP);
		MapHashToImmutableFraction { obj_id: map_id }
	}

    pub fn owner(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))
	}

    pub fn price_per_mg(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.id, idx_map(IDX_STATE_PRICE_PER_MG))
	}

    pub fn productpasses(&self) -> MapHashToImmutableProductPass {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_PRODUCTPASSES), TYPE_MAP);
		MapHashToImmutableProductPass { obj_id: map_id }
	}

    pub fn recy_compositions(&self) -> MapHashToImmutableRecyCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_RECY_COMPOSITIONS), TYPE_MAP);
		MapHashToImmutableRecyCompositions { obj_id: map_id }
	}

    pub fn recyclates(&self) -> MapHashToImmutableRecyclate {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_RECYCLATES), TYPE_MAP);
		MapHashToImmutableRecyclate { obj_id: map_id }
	}

    pub fn share_recycler(&self) -> ScImmutableUint8 {
		ScImmutableUint8::new(self.id, idx_map(IDX_STATE_SHARE_RECYCLER))
	}
}

pub struct MapHashToMutableCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableCompositions {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_compositions(&self, key: &ScHash) -> MutableCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        MutableCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToMutableFracCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableFracCompositions {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_frac_compositions(&self, key: &ScHash) -> MutableFracCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        MutableFracCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToMutableFraction {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableFraction {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_fraction(&self, key: &ScHash) -> MutableFraction {
        MutableFraction { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

pub struct MapHashToMutableProductPass {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableProductPass {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_product_pass(&self, key: &ScHash) -> MutableProductPass {
        MutableProductPass { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

pub struct MapHashToMutableRecyCompositions {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableRecyCompositions {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_recy_compositions(&self, key: &ScHash) -> MutableRecyCompositions {
        let sub_id = get_object_id(self.obj_id, key.get_key_id(), TYPE_ARRAY | TYPE_BYTES);
        MutableRecyCompositions { obj_id: sub_id }
    }
}

pub struct MapHashToMutableRecyclate {
	pub(crate) obj_id: i32,
}

impl MapHashToMutableRecyclate {
    pub fn clear(&self) {
        clear(self.obj_id);
    }

    pub fn get_recyclate(&self, key: &ScHash) -> MutableRecyclate {
        MutableRecyclate { obj_id: self.obj_id, key_id: key.get_key_id() }
    }
}

#[derive(Clone, Copy)]
pub struct Mutabletest3State {
    pub(crate) id: i32,
}

impl Mutabletest3State {
    pub fn compositions(&self) -> MapHashToMutableCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_COMPOSITIONS), TYPE_MAP);
		MapHashToMutableCompositions { obj_id: map_id }
	}

    pub fn frac_compositions(&self) -> MapHashToMutableFracCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_FRAC_COMPOSITIONS), TYPE_MAP);
		MapHashToMutableFracCompositions { obj_id: map_id }
	}

    pub fn fractions(&self) -> MapHashToMutableFraction {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_FRACTIONS), TYPE_MAP);
		MapHashToMutableFraction { obj_id: map_id }
	}

    pub fn owner(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))
	}

    pub fn price_per_mg(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.id, idx_map(IDX_STATE_PRICE_PER_MG))
	}

    pub fn productpasses(&self) -> MapHashToMutableProductPass {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_PRODUCTPASSES), TYPE_MAP);
		MapHashToMutableProductPass { obj_id: map_id }
	}

    pub fn recy_compositions(&self) -> MapHashToMutableRecyCompositions {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_RECY_COMPOSITIONS), TYPE_MAP);
		MapHashToMutableRecyCompositions { obj_id: map_id }
	}

    pub fn recyclates(&self) -> MapHashToMutableRecyclate {
		let map_id = get_object_id(self.id, idx_map(IDX_STATE_RECYCLATES), TYPE_MAP);
		MapHashToMutableRecyclate { obj_id: map_id }
	}

    pub fn share_recycler(&self) -> ScMutableUint8 {
		ScMutableUint8::new(self.id, idx_map(IDX_STATE_SHARE_RECYCLER))
	}
}
