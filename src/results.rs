// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use wasmlib::host::*;

use crate::*;
use crate::keys::*;
use crate::structs::*;
use crate::typedefs::*;

#[derive(Clone, Copy)]
pub struct ImmutableAddPPToFractionResults {
    pub(crate) id: i32,
}

impl ImmutableAddPPToFractionResults {
    pub fn frac_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.id, idx_map(IDX_RESULT_FRAC_ID))
	}

    pub fn pp(&self) -> ImmutableProductPass {
		ImmutableProductPass { obj_id: self.id, key_id: idx_map(IDX_RESULT_PP) }
	}
}

#[derive(Clone, Copy)]
pub struct MutableAddPPToFractionResults {
    pub(crate) id: i32,
}

impl MutableAddPPToFractionResults {
    pub fn frac_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.id, idx_map(IDX_RESULT_FRAC_ID))
	}

    pub fn pp(&self) -> MutableProductPass {
		MutableProductPass { obj_id: self.id, key_id: idx_map(IDX_RESULT_PP) }
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableCreateFractionResults {
    pub(crate) id: i32,
}

impl ImmutableCreateFractionResults {
    pub fn frac_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.id, idx_map(IDX_RESULT_FRAC_ID))
	}
}

#[derive(Clone, Copy)]
pub struct MutableCreateFractionResults {
    pub(crate) id: i32,
}

impl MutableCreateFractionResults {
    pub fn frac_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.id, idx_map(IDX_RESULT_FRAC_ID))
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableCreatePPResults {
    pub(crate) id: i32,
}

impl ImmutableCreatePPResults {
    pub fn id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.id, idx_map(IDX_RESULT_ID))
	}
}

#[derive(Clone, Copy)]
pub struct MutableCreatePPResults {
    pub(crate) id: i32,
}

impl MutableCreatePPResults {
    pub fn id(&self) -> ScMutableHash {
		ScMutableHash::new(self.id, idx_map(IDX_RESULT_ID))
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableCreateRecyclateResults {
    pub(crate) id: i32,
}

impl ImmutableCreateRecyclateResults {
    pub fn fraction(&self) -> ImmutableFraction {
		ImmutableFraction { obj_id: self.id, key_id: idx_map(IDX_RESULT_FRACTION) }
	}

    pub fn recyclate_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.id, idx_map(IDX_RESULT_RECYCLATE_ID))
	}
}

#[derive(Clone, Copy)]
pub struct MutableCreateRecyclateResults {
    pub(crate) id: i32,
}

impl MutableCreateRecyclateResults {
    pub fn fraction(&self) -> MutableFraction {
		MutableFraction { obj_id: self.id, key_id: idx_map(IDX_RESULT_FRACTION) }
	}

    pub fn recyclate_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.id, idx_map(IDX_RESULT_RECYCLATE_ID))
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableGetAmountOfRequiredFundsResults {
    pub(crate) id: i32,
}

impl ImmutableGetAmountOfRequiredFundsResults {
    pub fn token_required(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.id, idx_map(IDX_RESULT_TOKEN_REQUIRED))
	}
}

#[derive(Clone, Copy)]
pub struct MutableGetAmountOfRequiredFundsResults {
    pub(crate) id: i32,
}

impl MutableGetAmountOfRequiredFundsResults {
    pub fn token_required(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.id, idx_map(IDX_RESULT_TOKEN_REQUIRED))
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableGetMaterialsResults {
    pub(crate) id: i32,
}

impl ImmutableGetMaterialsResults {
    pub fn compositions(&self) -> ImmutableCompositions {
		let sub_id = get_object_id(self.id, idx_map(IDX_RESULT_COMPOSITIONS), TYPE_ARRAY | TYPE_BYTES);
		ImmutableCompositions { obj_id: sub_id }
	}
}

#[derive(Clone, Copy)]
pub struct MutableGetMaterialsResults {
    pub(crate) id: i32,
}

impl MutableGetMaterialsResults {
    pub fn compositions(&self) -> MutableCompositions {
		let sub_id = get_object_id(self.id, idx_map(IDX_RESULT_COMPOSITIONS), TYPE_ARRAY | TYPE_BYTES);
		MutableCompositions { obj_id: sub_id }
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableGetOwnerResults {
    pub(crate) id: i32,
}

impl ImmutableGetOwnerResults {
    pub fn owner(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.id, idx_map(IDX_RESULT_OWNER))
	}
}

#[derive(Clone, Copy)]
pub struct MutableGetOwnerResults {
    pub(crate) id: i32,
}

impl MutableGetOwnerResults {
    pub fn owner(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.id, idx_map(IDX_RESULT_OWNER))
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableGetPPResults {
    pub(crate) id: i32,
}

impl ImmutableGetPPResults {
    pub fn ppname(&self) -> ScImmutableString {
		ScImmutableString::new(self.id, idx_map(IDX_RESULT_PPNAME))
	}

    pub fn ppresult(&self) -> ImmutableProductPass {
		ImmutableProductPass { obj_id: self.id, key_id: idx_map(IDX_RESULT_PPRESULT) }
	}
}

#[derive(Clone, Copy)]
pub struct MutableGetPPResults {
    pub(crate) id: i32,
}

impl MutableGetPPResults {
    pub fn ppname(&self) -> ScMutableString {
		ScMutableString::new(self.id, idx_map(IDX_RESULT_PPNAME))
	}

    pub fn ppresult(&self) -> MutableProductPass {
		MutableProductPass { obj_id: self.id, key_id: idx_map(IDX_RESULT_PPRESULT) }
	}
}

#[derive(Clone, Copy)]
pub struct ImmutableGetTokenPerPackageResults {
    pub(crate) id: i32,
}

impl ImmutableGetTokenPerPackageResults {
    pub fn token_per_package(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.id, idx_map(IDX_RESULT_TOKEN_PER_PACKAGE))
	}
}

#[derive(Clone, Copy)]
pub struct MutableGetTokenPerPackageResults {
    pub(crate) id: i32,
}

impl MutableGetTokenPerPackageResults {
    pub fn token_per_package(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.id, idx_map(IDX_RESULT_TOKEN_PER_PACKAGE))
	}
}
