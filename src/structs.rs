// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use wasmlib::host::*;
use crate::typedefs::*;

pub struct Composition {
    pub material   : String, 
    pub proportion : u8, 
}

impl Composition {
    pub fn from_bytes(bytes: &[u8]) -> Composition {
        let mut decode = BytesDecoder::new(bytes);
        Composition {
            material   : decode.string(),
            proportion : decode.uint8(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.string(&self.material);
		encode.uint8(self.proportion);
        return encode.data();
    }
}

pub struct ImmutableComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableComposition {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> Composition {
        Composition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableComposition {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &Composition) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> Composition {
        Composition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct FracComposition {
    pub material : String, 
    pub weight   : u64,  //in mg
}

impl FracComposition {
    pub fn from_bytes(bytes: &[u8]) -> FracComposition {
        let mut decode = BytesDecoder::new(bytes);
        FracComposition {
            material : decode.string(),
            weight   : decode.uint64(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.string(&self.material);
		encode.uint64(self.weight);
        return encode.data();
    }
}

pub struct ImmutableFracComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableFracComposition {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> FracComposition {
        FracComposition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableFracComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableFracComposition {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &FracComposition) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> FracComposition {
        FracComposition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct Fraction {
    pub amount      : i64, 
    pub dec_food    : bool, 
    pub dec_hygiene : bool, 
    pub did         : String, 
    pub frac_id     : ScHash, 
    pub issuer      : ScAgentID, 
    pub name        : String, 
}

impl Fraction {
    pub fn from_bytes(bytes: &[u8]) -> Fraction {
        let mut decode = BytesDecoder::new(bytes);
        Fraction {
            amount      : decode.int64(),
            dec_food    : decode.bool(),
            dec_hygiene : decode.bool(),
            did         : decode.string(),
            frac_id     : decode.hash(),
            issuer      : decode.agent_id(),
            name        : decode.string(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.int64(self.amount);
		encode.bool(self.dec_food);
		encode.bool(self.dec_hygiene);
		encode.string(&self.did);
		encode.hash(&self.frac_id);
		encode.agent_id(&self.issuer);
		encode.string(&self.name);
        return encode.data();
    }
}

pub struct ImmutableFraction {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableFraction {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> Fraction {
        Fraction::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableFraction {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableFraction {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &Fraction) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> Fraction {
        Fraction::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct ProductPass {
    pub amount         : i64, 
    pub charge_weight  : u64, 
    pub dec_food       : bool, 
    pub dec_hygiene    : bool, 
    pub did            : String,  //merged did:iota:id
    pub id             : ScHash, 
    pub issuer         : ScAgentID,  //packaging producer
    pub name           : String, 
    pub package_weight : u64, 
    pub version        : u8, 
}

impl ProductPass {
    pub fn from_bytes(bytes: &[u8]) -> ProductPass {
        let mut decode = BytesDecoder::new(bytes);
        ProductPass {
            amount         : decode.int64(),
            charge_weight  : decode.uint64(),
            dec_food       : decode.bool(),
            dec_hygiene    : decode.bool(),
            did            : decode.string(),
            id             : decode.hash(),
            issuer         : decode.agent_id(),
            name           : decode.string(),
            package_weight : decode.uint64(),
            version        : decode.uint8(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.int64(self.amount);
		encode.uint64(self.charge_weight);
		encode.bool(self.dec_food);
		encode.bool(self.dec_hygiene);
		encode.string(&self.did);
		encode.hash(&self.id);
		encode.agent_id(&self.issuer);
		encode.string(&self.name);
		encode.uint64(self.package_weight);
		encode.uint8(self.version);
        return encode.data();
    }
}

pub struct ImmutableProductPass {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableProductPass {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> ProductPass {
        ProductPass::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableProductPass {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableProductPass {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &ProductPass) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> ProductPass {
        ProductPass::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct RecyComposition {
    pub material : String, 
    pub weight   : u64,  //in mg
}

impl RecyComposition {
    pub fn from_bytes(bytes: &[u8]) -> RecyComposition {
        let mut decode = BytesDecoder::new(bytes);
        RecyComposition {
            material : decode.string(),
            weight   : decode.uint64(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.string(&self.material);
		encode.uint64(self.weight);
        return encode.data();
    }
}

pub struct ImmutableRecyComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableRecyComposition {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> RecyComposition {
        RecyComposition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableRecyComposition {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableRecyComposition {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &RecyComposition) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> RecyComposition {
        RecyComposition::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct Recyclate {
    pub amount      : i64, 
    pub dec_food    : bool, 
    pub dec_hygiene : bool, 
    pub did         : String, 
    pub issuer      : ScAgentID, 
    pub name        : String, 
    pub recy_id     : ScHash, 
}

impl Recyclate {
    pub fn from_bytes(bytes: &[u8]) -> Recyclate {
        let mut decode = BytesDecoder::new(bytes);
        Recyclate {
            amount      : decode.int64(),
            dec_food    : decode.bool(),
            dec_hygiene : decode.bool(),
            did         : decode.string(),
            issuer      : decode.agent_id(),
            name        : decode.string(),
            recy_id     : decode.hash(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.int64(self.amount);
		encode.bool(self.dec_food);
		encode.bool(self.dec_hygiene);
		encode.string(&self.did);
		encode.agent_id(&self.issuer);
		encode.string(&self.name);
		encode.hash(&self.recy_id);
        return encode.data();
    }
}

pub struct ImmutableRecyclate {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableRecyclate {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> Recyclate {
        Recyclate::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

pub struct MutableRecyclate {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableRecyclate {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &Recyclate) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> Recyclate {
        Recyclate::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}
