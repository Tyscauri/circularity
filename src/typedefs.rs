// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;
use crate::*;

#[derive(Clone)]
pub struct ArrayOfImmutableComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfImmutableComposition {
    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_composition(&self, index: u32) -> ImmutableComposition {
		ImmutableComposition { proxy: self.proxy.index(index) }
	}
}

pub type ImmutableCompositions = ArrayOfImmutableComposition;

#[derive(Clone)]
pub struct ArrayOfMutableComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfMutableComposition {

	pub fn append_composition(&self) -> MutableComposition {
		MutableComposition { proxy: self.proxy.append() }
	}
	pub fn clear(&self) {
        self.proxy.clear_array();
    }

    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_composition(&self, index: u32) -> MutableComposition {
		MutableComposition { proxy: self.proxy.index(index) }
	}
}

pub type MutableCompositions = ArrayOfMutableComposition;

#[derive(Clone)]
pub struct ArrayOfImmutableFracComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfImmutableFracComposition {
    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_frac_composition(&self, index: u32) -> ImmutableFracComposition {
		ImmutableFracComposition { proxy: self.proxy.index(index) }
	}
}

pub type ImmutableFracCompositions = ArrayOfImmutableFracComposition;

#[derive(Clone)]
pub struct ArrayOfMutableFracComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfMutableFracComposition {

	pub fn append_frac_composition(&self) -> MutableFracComposition {
		MutableFracComposition { proxy: self.proxy.append() }
	}
	pub fn clear(&self) {
        self.proxy.clear_array();
    }

    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_frac_composition(&self, index: u32) -> MutableFracComposition {
		MutableFracComposition { proxy: self.proxy.index(index) }
	}
}

pub type MutableFracCompositions = ArrayOfMutableFracComposition;

#[derive(Clone)]
pub struct ArrayOfImmutableAgentID {
	pub(crate) proxy: Proxy,
}

impl ArrayOfImmutableAgentID {
    pub fn length(&self) -> u32 {
        self.proxy.length()
    }

    pub fn get_agent_id(&self, index: u32) -> ScImmutableAgentID {
        ScImmutableAgentID::new(self.proxy.index(index))
    }
}

pub type ImmutableFracPayoffKeys = ArrayOfImmutableAgentID;

#[derive(Clone)]
pub struct ArrayOfMutableAgentID {
	pub(crate) proxy: Proxy,
}

impl ArrayOfMutableAgentID {
	pub fn append_agent_id(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.append())
	}

	pub fn clear(&self) {
        self.proxy.clear_array();
    }

    pub fn length(&self) -> u32 {
        self.proxy.length()
    }

    pub fn get_agent_id(&self, index: u32) -> ScMutableAgentID {
        ScMutableAgentID::new(self.proxy.index(index))
    }
}

pub type MutableFracPayoffKeys = ArrayOfMutableAgentID;

#[derive(Clone)]
pub struct MapAgentIDToImmutableUint64 {
	pub(crate) proxy: Proxy,
}

impl MapAgentIDToImmutableUint64 {
    pub fn get_uint64(&self, key: &ScAgentID) -> ScImmutableUint64 {
        ScImmutableUint64::new(self.proxy.key(&agent_id_to_bytes(key)))
    }
}

pub type ImmutableFracPayoffs = MapAgentIDToImmutableUint64;

#[derive(Clone)]
pub struct MapAgentIDToMutableUint64 {
	pub(crate) proxy: Proxy,
}

impl MapAgentIDToMutableUint64 {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_uint64(&self, key: &ScAgentID) -> ScMutableUint64 {
        ScMutableUint64::new(self.proxy.key(&agent_id_to_bytes(key)))
    }
}

pub type MutableFracPayoffs = MapAgentIDToMutableUint64;

#[derive(Clone)]
pub struct ArrayOfImmutableRecyComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfImmutableRecyComposition {
    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_recy_composition(&self, index: u32) -> ImmutableRecyComposition {
		ImmutableRecyComposition { proxy: self.proxy.index(index) }
	}
}

pub type ImmutableRecyCompositions = ArrayOfImmutableRecyComposition;

#[derive(Clone)]
pub struct ArrayOfMutableRecyComposition {
	pub(crate) proxy: Proxy,
}

impl ArrayOfMutableRecyComposition {

	pub fn append_recy_composition(&self) -> MutableRecyComposition {
		MutableRecyComposition { proxy: self.proxy.append() }
	}
	pub fn clear(&self) {
        self.proxy.clear_array();
    }

    pub fn length(&self) -> u32 {
        self.proxy.length()
    }


	pub fn get_recy_composition(&self, index: u32) -> MutableRecyComposition {
		MutableRecyComposition { proxy: self.proxy.index(index) }
	}
}

pub type MutableRecyCompositions = ArrayOfMutableRecyComposition;
